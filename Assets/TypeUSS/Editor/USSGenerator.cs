using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor;

namespace TypeUSS.Editor
{
    public static class USSGenerator
    {
        private const string GeneratedHeader = "/* Auto-generated by TypeUSS - Do not edit manually */";

        public static List<string> GenerateAll()
        {
            var generatedFiles = new List<string>();
            var styleClasses = FindAllStyleClasses();

            foreach (var (type, attribute) in styleClasses)
            {
                try
                {
                    var ussContent = GenerateUSSForClass(type, attribute);
                    var outputPath = WriteUSSFile(attribute.OutputPath, ussContent);
                    generatedFiles.Add(outputPath);

                    Debug.Log($"[TypeUSS] Generated: {outputPath}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[TypeUSS] Failed to generate USS for {type.FullName}: {ex.Message}\n{ex.StackTrace}");
                }
            }

            if (generatedFiles.Count > 0)
            {
                AssetDatabase.Refresh();
                EditorApplication.delayCall += () => UpdateStyleSheetReferences(generatedFiles);
            }

            return generatedFiles;
        }

        public static string GenerateUSSForClass(Type type, GenerateUSSAttribute attribute)
        {
            var styles = ExtractStyles(type);
            return BuildUSSContent(styles, attribute.Header);
        }

        private static void UpdateStyleSheetReferences(List<string> generatedFiles)
        {
            var styleSheets = new List<StyleSheet>();

            foreach (var path in generatedFiles)
            {
                var sheet = AssetDatabase.LoadAssetAtPath<StyleSheet>(path);
                if (sheet != null)
                {
                    styleSheets.Add(sheet);
                }
                else
                {
                    Debug.LogWarning($"[TypeUSS] Could not load StyleSheet at {path}");
                }
            }

            if (styleSheets.Count == 0) return;

            // Find all MonoBehaviours with a StyleSheet[] field marked with [TypeUSSStyleSheets]
            // Or specifically look for types implementing a known interface/base class
            // For simplicity, we'll search for any field named "styleSheets" of type StyleSheet[]
            var installers = FindStyleSheetConsumers();

            foreach (var installer in installers)
            {
                var field = installer.GetType()
                    .GetField("styleSheets", BindingFlags.NonPublic | BindingFlags.Instance);

                if (field != null && field.FieldType == typeof(StyleSheet[]))
                {
                    field.SetValue(installer, styleSheets.ToArray());
                    EditorUtility.SetDirty(installer);
                    Debug.Log($"[TypeUSS] Updated {installer.GetType().Name} with {styleSheets.Count} stylesheets");
                }
            }
        }

        private static List<MonoBehaviour> FindStyleSheetConsumers()
        {
            var results = new List<MonoBehaviour>();

            // Search in all open scenes
            for (int i = 0; i < UnityEngine.SceneManagement.SceneManager.sceneCount; i++)
            {
                var scene = UnityEngine.SceneManagement.SceneManager.GetSceneAt(i);
                if (!scene.isLoaded) continue;

                foreach (var root in scene.GetRootGameObjects())
                {
                    results.AddRange(root.GetComponentsInChildren<MonoBehaviour>(true)
                        .Where(mb => mb != null && HasStyleSheetsField(mb.GetType())));
                }
            }

            return results;
        }

        private static bool HasStyleSheetsField(Type type)
        {
            var field = type.GetField("styleSheets", BindingFlags.NonPublic | BindingFlags.Instance);
            return field != null && field.FieldType == typeof(StyleSheet[]);
        }

        private static IEnumerable<(Type type, GenerateUSSAttribute attr)> FindAllStyleClasses()
        {
            return AppDomain.CurrentDomain.GetAssemblies()
                .Where(a => !a.IsDynamic &&
                            !a.FullName.StartsWith("System") &&
                            !a.FullName.StartsWith("Microsoft") &&
                            !a.FullName.StartsWith("Unity.") &&
                            !a.FullName.StartsWith("UnityEngine") &&
                            !a.FullName.StartsWith("UnityEditor") &&
                            !a.FullName.StartsWith("mscorlib") &&
                            !a.FullName.StartsWith("netstandard"))
                .SelectMany(a =>
                {
                    try { return a.GetTypes(); }
                    catch { return Array.Empty<Type>(); }
                })
                .Select(t => (type: t, attr: t.GetCustomAttribute<GenerateUSSAttribute>()))
                .Where(x => x.attr != null);
        }

        private static List<TypeStyle> ExtractStyles(Type type)
        {
            var styles = new List<TypeStyle>();

            var styleFields = type.GetFields(BindingFlags.Public | BindingFlags.Static)
                .Where(f => f.FieldType == typeof(TypeStyle));

            foreach (var field in styleFields)
            {
                try
                {
                    var style = (TypeStyle)field.GetValue(null);
                    if (style != null)
                    {
                        styles.Add(style);
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[TypeUSS] Could not extract style from {type.Name}.{field.Name}: {ex.Message}");
                }
            }

            var styleProperties = type.GetProperties(BindingFlags.Public | BindingFlags.Static)
                .Where(p => p.PropertyType == typeof(TypeStyle) && p.CanRead);

            foreach (var prop in styleProperties)
            {
                try
                {
                    var style = (TypeStyle)prop.GetValue(null);
                    if (style != null)
                    {
                        styles.Add(style);
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[TypeUSS] Could not extract style from {type.Name}.{prop.Name}: {ex.Message}");
                }
            }

            return styles;
        }

        private static string BuildUSSContent(List<TypeStyle> styles, string customHeader)
        {
            var sb = new StringBuilder();

            sb.AppendLine(GeneratedHeader);
            if (!string.IsNullOrEmpty(customHeader))
            {
                sb.AppendLine($"/* {customHeader} */");
            }
            sb.AppendLine();

            foreach (var style in styles)
            {
                sb.AppendLine(style.ToUSS());
                sb.AppendLine();
            }

            return sb.ToString().TrimEnd();
        }

        private static string WriteUSSFile(string relativePath, string content)
        {
            if (!relativePath.StartsWith("Assets/") && !relativePath.StartsWith("Assets\\"))
            {
                relativePath = Path.Combine("Assets", relativePath);
            }

            if (!relativePath.EndsWith(".uss", StringComparison.OrdinalIgnoreCase))
            {
                relativePath += ".uss";
            }

            relativePath = relativePath.Replace("\\", "/");

            var fullPath = Path.GetFullPath(relativePath);
            var directory = Path.GetDirectoryName(fullPath);

            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            if (File.Exists(fullPath))
            {
                var existingContent = File.ReadAllText(fullPath);
                if (existingContent == content)
                {
                    return relativePath;
                }
            }

            File.WriteAllText(fullPath, content);
            return relativePath;
        }
    }
}
